parse set logic start. 
parse logic :QF_S
parse set logic end. 
parse declare sort start. 
declare-sort: Sll_t 0
parse declare sort end. 
parse declare-fun start.
parse fun name: next
parse parameters end.
parser parameters, empty: 1
new filed: next
new variable: next
parse declare-fun end.
parse define-fun start.
parse fun name: ls
parse parameters end.
parse the number of parameters : 2
parse range type: Space
make func decl: (declare-fun ls (Sll_t Sll_t) Space)
parse expr start.
parse parameters end.
expr stack size: 1
expr frame stack size: 0
the last expr:
(let ((a!1 (or (and (= ?in ?out) (tobool emp))
               (exists ((?u Sll_t))
                 (let ((a!1 (tobool (ssep (pto ?in (ref next ?u)) (ls ?u ?out)))))
                   (and (distinct ?in ?out) a!1))))))
  (tospace a!1))
parse expr end.
parse define-fun end.parse declare-fun start.
parse fun name: y_emp
parse parameters end.
parser parameters, empty: 1
new variable: y_emp
parse declare-fun end.
parse declare-fun start.
parse fun name: w_emp
parse parameters end.
parser parameters, empty: 1
new variable: w_emp
parse declare-fun end.
parse declare-fun start.
parse fun name: z_emp
parse parameters end.
parser parameters, empty: 1
new variable: z_emp
parse declare-fun end.
parse assert start.
parse expr start.
expr stack size: 1
expr frame stack size: 0
the last expr:
(tobool (ssep (pto y_emp (ref next z_emp))
              (ls y_emp w_emp)
              (pto w_emp (ref next z_emp))))
parse expr end.
parse assert end.
solve the sat ...
list sat problem: 
